## Комментарии по заданию:
1. Сделал связь Many-to-Many, как указано в задании, хотя исходя из описания, тут скорее подошло бы One-to-Many
   (т.к. при создании передается только один айди Venue).
2. Не понятно, как предполагалось создание нового Venue (при запросе пытается достать из базы уже существующее),
   поэтому немного изменил эту логику, чтобы была возможность создавать новые Venue и изменять существующие.
3. Из-за отсутствия создания, не понятно было, откуда должно браться 'referenceId', поэтому условно сделал его равным
   'externalId'.
4. Добавил два запроса на получение списка Event (с лимитом) и получения списка Event для конкретного Venue.
5. Тесты не сделал. Можно сделать либо обычные юнит-тесты, либо с использованием DgsQueryExecutor (с @EnableDgsTest).
   Нагрузочные - в зависимости от требований (Jmeter, Gatling, k6).

## Комментарии по приложению и архитектуре:
1. Не совсем понятно, почему для Venue решено было сделать такой составной ключ (выглядит избыточно и усложняет разработку)
2. Как уже писал, больше похое на то, что должна быть связь Many-to-One ежду этими сущностями, что в значительной степени
   упростило бы разработку.
3. Не совсем понятно решение сохраниния сущностей в базу через ивенты. Даже если предполагается, что будут создаваться
   еще различные обработчики для этих событий, то все равно само сохранение лучше производить синхронно, чтобы данные
   точно не потерялись и в ответ ушли актуальные. Также, это избавит от проблемы, что в ответе не получить айди нового
   объекта, т.к. оно генерируется (обычно) при сохранении в БД. Генерация айди по запросу (как сейчас это реализовано в Venue)
   не самый предпочтительный вариант.
4. Добавить логику для пагинации, фильтрации, запросы на удаление и т.п.
5. Из более глобального - добавить обработчики ошибок, валидацию параметров запросов, логирование, переименовать некоторые классы.
