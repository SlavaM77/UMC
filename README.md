## Комментарии по заданию:
1. Сделал связь Many-to-Many, как указано в задании, хотя исходя из описания, тут скорее подошло бы One-to-Many
   (т.к. при создании передается только один айди Venue).
2. Непонятно, как предполагалось создание нового Venue (при запросе пытается достать из базы уже существующее),
   поэтому немного изменил эту логику, чтобы была возможность создавать новые Venue и изменять существующие.
3. Из-за отсутствия создания, не понятно было, откуда должно браться 'referenceId', поэтому условно сделал его равным
   'externalId'.
4. Добавил два запроса на получение списка Event (с лимитом) и получение списка Event для конкретного Venue.
5. Тесты не сделал. Можно сделать либо обычные юнит-тесты, либо с использованием DgsQueryExecutor (с @EnableDgsTest).
   Нагрузочные - в зависимости от требований (Jmeter, Gatling, k6).

## Комментарии по приложению и архитектуре:
1. Не совсем понятно, почему для Venue решено было сделать такой составной ключ (выглядит избыточно и усложняет разработку).
2. Как уже писал, больше похоже на то, что должна быть связь Many-to-One между этими сущностями, что в значительной степени
   упростило бы разработку.
3. Не совсем понятно решение сохранения сущностей в базу через ивенты. Даже если предполагается, что будут создаваться
   еще различные обработчики для этих событий, то все равно само сохранение лучше производить синхронно, чтобы данные
   точно не потерялись и в ответе вернулись актуальные. Также, это избавит от проблемы, что в ответе не получить айди нового
   объекта, так как оно генерируется (обычно) при сохранении в БД. Генерация айди по запросу (как сейчас это реализовано в Venue) - 
   не самый предпочтительный вариант.
4. Добавить логику для пагинации, фильтрации, запросов на удаление и т.п.
5. Из более глобального - добавить обработчики ошибок, валидацию параметров запросов, логирование, переименовать некоторые классы.
